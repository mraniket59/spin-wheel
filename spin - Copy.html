<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spin the Wheel ‚Äî Working Demo</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#ffb86b;--text:#e6eef8}
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071025 0%,#071827 60%);color:var(--text)}
    .container{width:920px;max-width:96%;display:grid;grid-template-columns:520px 1fr;gap:18px;align-items:center}
    .card{background:rgba(255,255,255,0.03);padding:18px;border-radius:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .wheel-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{border-radius:999px;display:block}
    .pointer{width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;border-bottom:28px solid var(--accent);position:relative;top:-24px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);color:#001018;border:none;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
    button[disabled]{opacity:0.5;cursor:default}
    label{display:flex;flex-direction:column;font-size:13px;color:#b9c7d8}
    input[type="text"]{padding:8px;border-radius:8px;border:none;background:rgba(255,255,255,0.02);color:var(--text)}
    .log{font-size:13px;color:#cfe8ff;margin-top:12px}
    .settings{display:flex;flex-direction:column;gap:10px}
    .segment-list{display:flex;flex-direction:column;gap:6px;max-height:240px;overflow:auto;padding-right:6px}
    .seg-row{display:flex;gap:8px}
    .seg-row input{flex:1}
    .small{font-size:12px;color:#9fb6d4}
    footer{grid-column:1/-1;margin-top:6px;color:#8da9c9;font-size:12px;text-align:center}
    @media(max-width:760px){.container{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="container">
    <div class="card wheel-wrap">
      <canvas id="wheel" width="480" height="480"></canvas>
      <div class="pointer" aria-hidden="true"></div>
      <div class="controls">
        <button id="spinBtn">SPIN</button>
        <button id="quickSpinBtn">QUICK SPIN</button>
        <button id="resetBtn">RESET</button>
      </div>
      <div class="log" id="result">Ready ‚Äî edit segments on the right, then press SPIN.</div>
    </div>

    <div class="card settings">
      <div>
        <label class="small">Segments (edit text, press Enter to save)</label>
        <div class="segment-list" id="segmentList"></div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <input id="newSegName" type="text" placeholder="New segment name" />
          <button id="addSegBtn">Add</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label class="small">Spin options</label>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <label>Animation time (s)
            <input id="spinTime" type="number" min="1" max="20" value="6" />
          </label>
          <label>Random seed
            <input id="seed" type="text" placeholder="leave blank for random" />
          </label>
        </div>
      </div>

      <div style="margin-top:12px">
        <p class="small">How it works: this is a single-file HTML+JS demo that draws segments on canvas, animates rotation with easing and random target selection. Edit the segments list to customize prizes or labels. Works offline in browser.</p>
      </div>
      <footer>Made with ‚ù§Ô∏è ‚Äî Customize the <code>segments</code> array or use the UI to add/remove segments.</footer>
    </div>
  </div>

  <script>
    // --- CONFIG: initial segments ---
    let segments = [
      '‚Çπ50 Off', 'Free Shipping', 'Try Again', '10% Off', 'Free Gift', 'Grand Prize', '5% Off', 'Better Luck'
    ];

    // --- DOM ---
    const canvas = document.getElementById('wheel');
    const ctx = canvas.getContext('2d');
    const spinBtn = document.getElementById('spinBtn');
    const quickSpinBtn = document.getElementById('quickSpinBtn');
    const resetBtn = document.getElementById('resetBtn');
    const resultEl = document.getElementById('result');
    const segmentList = document.getElementById('segmentList');
    const addSegBtn = document.getElementById('addSegBtn');
    const newSegName = document.getElementById('newSegName');
    const spinTimeInput = document.getElementById('spinTime');
    const seedInput = document.getElementById('seed');

    // canvas sizing
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const size = Math.min(480, Math.floor(Math.min(window.innerWidth*0.62, 480)));
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // colors for segments
    function getColor(i){
      const palette = ['#f97316','#06b6d4','#f43f5e','#f59e0b','#7c3aed','#10b981','#ef4444','#3b82f6','#f472b6','#14b8a6'];
      return palette[i % palette.length];
    }

    // draw wheel
    let rotation = 0; // radians
    function draw(){
      const w = canvas.clientWidth;
      const cx = w/2, cy = w/2, radius = w/2 - 8;
      ctx.clearRect(0,0,w,w);
      const segCount = segments.length || 1;
      const arc = (Math.PI*2) / segCount;

      // segments
      for(let i=0;i<segCount;i++){
        const start = rotation + i*arc;
        const end = start + arc;
        // background
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,radius,start,end);
        ctx.closePath();
        ctx.fillStyle = getColor(i);
        ctx.fill();
        // stroke
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.stroke();

        // text
        ctx.save();
        ctx.translate(cx,cy);
        const angle = start + arc/2;
        ctx.rotate(angle + Math.PI/2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#001018';
        ctx.font = Math.max(12, radius/10) + 'px sans-serif';
        // break long labels
        const label = segments[i] || '';
        wrapText(ctx, label, radius*0.6, -radius*0.35);
        ctx.restore();
      }

      // center circle
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.25,0,Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fill();

      // pointer (drawn on canvas aligned to top)
      ctx.beginPath();
      ctx.moveTo(cx - 12, 8);
      ctx.lineTo(cx + 12, 8);
      ctx.lineTo(cx, 36);
      ctx.closePath();
      ctx.fillStyle = 'var(--accent)';
      ctx.fill();
    }

    // wrap text into multiple lines within maxWidth
    function wrapText(ctx, text, maxWidth, y){
      const words = text.split(' ');
      let line = '';
      const lines = [];
      for(let n=0;n<words.length;n++){
        const testLine = line + (line? ' ' : '') + words[n];
        const metrics = ctx.measureText(testLine);
        if(metrics.width > maxWidth && n>0){
          lines.push(line);
          line = words[n];
        } else {
          line = testLine;
        }
      }
      if(line) lines.push(line);
      const lineHeight = parseInt(ctx.font,10) + 2;
      for(let i=0;i<lines.length;i++){
        ctx.fillText(lines[i], 0, y + i*lineHeight);
      }
    }

    // UI helpers
    function rebuildSegmentList(){
      segmentList.innerHTML = '';
      segments.forEach((s,i)=>{
        const row = document.createElement('div');
        row.className = 'seg-row';
        const input = document.createElement('input');
        input.type = 'text';
        input.value = s;
        input.addEventListener('change', ()=>{ segments[i] = input.value || 'Untitled'; draw(); });
        input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') input.blur(); });
        const del = document.createElement('button');
        del.textContent = '‚úï';
        del.title = 'Remove';
        del.style.padding = '6px 8px';
        del.addEventListener('click', ()=>{ segments.splice(i,1); rebuildSegmentList(); draw(); });
        row.appendChild(input);
        row.appendChild(del);
        segmentList.appendChild(row);
      });
    }

    addSegBtn.addEventListener('click', ()=>{
      const v = newSegName.value.trim();
      if(!v) return;
      segments.push(v);
      newSegName.value = '';
      rebuildSegmentList();
      draw();
    });

    // RNG: allow optional seed
    function rngFactory(seed){
      if(!seed) return Math.random;
      // simple mulberry32
      let h = 2166136261 >>> 0;
      for(let i=0;i<seed.length;i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
      let t = h + 0x6D2B79F5;
      return function(){ t += 0x6D2B79F5; let r = Math.imul(t ^ t >>> 15, t | 1); r ^= r + Math.imul(r ^ r >>> 7, r | 61); return ((r ^ r >>> 14) >>> 0) / 4294967296; };
    }

    // spin mechanics
    let spinning = false;
    let animFrame;
    function spin(options={duration:6, quick:false}){
      if(spinning) return;
      if(segments.length === 0) return alert('Add at least one segment');
      spinning = true;
      spinBtn.disabled = true;
      quickSpinBtn.disabled = true;
      resetBtn.disabled = true;

      const seed = seedInput.value.trim();
      const rng = rngFactory(seed);
      const segCount = segments.length;
      const arc = (Math.PI*2)/segCount;

      // choose a random target index
      const r = rng();
      const chosenIndex = Math.floor(r*segCount);

      // compute target angle so chosenIndex lands at pointer (top)
      // pointer angle is -PI/2 (top). We want the middle of chosen segment to align there.
      const targetSegmentCenter = (chosenIndex + 0.5) * arc;
      // current rotation is 'rotation' (radians), we need to rotate so that rotation + totalRotation + targetSegmentCenter = -PI/2  (mod 2PI)
      const current = rotation % (Math.PI*2);
      const desiredFinal = -Math.PI/2 - targetSegmentCenter;

      // normalize
      function norm(a){
        return ((a % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
      }
      const curN = norm(current);
      const wantN = norm(desiredFinal);
      // pick extra spins (full rotations)
      const minRounds = options.quick ? 2 : 5;
      const extraRounds = Math.floor(rng()*3) + minRounds; // adds randomness
      const totalRotationNeeded = (wantN - curN) + extraRounds * (Math.PI*2);

      const startTime = performance.now();
      const duration = Math.max(0.6, (options.duration || parseFloat(spinTimeInput.value) || 6) * 1000);

      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

      function animate(now){
        const t = Math.min(1, (now - startTime) / duration);
        const eased = easeOutCubic(t);
        rotation = current + totalRotationNeeded * eased;
        draw();
        if(t < 1){
          animFrame = requestAnimationFrame(animate);
        } else {
          spinning = false;
          spinBtn.disabled = false;
          quickSpinBtn.disabled = false;
          resetBtn.disabled = false;
          // final chosen index (safety: recompute from final rotation)
          const finalAngle = norm(-rotation + Math.PI/2); // convert to wheel-based angle
          let landed = Math.floor(finalAngle / arc) % segCount;
          landed = (segCount - 1 - landed + segCount) % segCount; // adjust orientation to match label order
          // landed should equal chosenIndex in most cases
          announceResult(segments[landed] || 'Untitled', landed);
        }
      }
      animFrame = requestAnimationFrame(animate);
    }

    function announceResult(label, index){
      resultEl.textContent = `üéâ Result: ${label} (segment ${index+1} of ${segments.length})`;
      // small confetti-ish effect: flash canvas border
      const orig = canvas.style.boxShadow;
      canvas.style.boxShadow = '0 0 40px 6px rgba(255,184,107,0.45)';
      setTimeout(()=> canvas.style.boxShadow = orig, 650);
      // optional: say the result with Web Speech API if available
      if('speechSynthesis' in window){
        const u = new SpeechSynthesisUtterance(`You won ${label}`);
        u.lang = 'en-US';
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      }
    }

    spinBtn.addEventListener('click', ()=> spin({duration:parseFloat(spinTimeInput.value) || 6, quick:false}));
    quickSpinBtn.addEventListener('click', ()=> spin({duration:Math.max(0.8, (parseFloat(spinTimeInput.value)||6)/3), quick:true}));
    resetBtn.addEventListener('click', ()=>{ if(spinning) cancelAnimationFrame(animFrame); spinning=false; rotation=0; draw(); resultEl.textContent='Reset ‚Äî ready'; spinBtn.disabled=false; quickSpinBtn.disabled=false; resetBtn.disabled=false; });

    // initial render & UI build
    function init(){
      rebuildSegmentList();
      resizeCanvas();
      resultEl.textContent = 'Ready ‚Äî edit segments on the right, then press SPIN.';
      draw();
    }
    init();
  </script>
</body>
</html>
